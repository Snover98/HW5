%{
/*C++ lang stuff*/
#include <iostream>
#include <sstream>
#include <stdlib.h>
#include "SymTable.h"
#include <vector>
#include "output.hpp"
#include <string>
#include "Node.h"
#include "bp.hpp"
#include "register_handler.h"
#include "utils.h"
#include "binary_operators.h"
#include "comparison_operators.h"
#include "func_generation.h"

extern int yylineno;

int yylex();
void yyerror(const char*);

//functions for enum type conversions
ExpType varToExp(VarType t);
VarType expToVar(ExpType e);

//functions for creating new scopes
void addEmptyScope();
void addFuncScope(const std::string &ID, const std::vector<FormalStruct> &formals, ExpType ret_type);
//function for removing scope
void popScope();
//function for type -> string conversion
std::string typeToString(VarType type);
//function for function -> string conversion
std::string funcToString(FunctionType &func_type);
//get function argument types vector as string
std::vector<std::string> funcArgTypes(FunctionType &func_type);
//func that adds print and printi to the symbol table
void addPrints();

void M3Code();
void M4Code();
//func that checks if an ID is already defined
void checkID(std::string& ID);

//the struct types defined in the code
std::vector <std::vector<StructType> > structs_stack;
//stack of symbol tables
std::vector<SymTable> tables_stack;
//number of conditional scopes (if/else/while) we are in, used to validate break statements
unsigned int num_of_while_scopes = 0;
//var for knowing what type the current function returns
ExpType cur_ret_type = VOIDEXP;

regHandler reg_handler;

std::string div_by_zero_label;

std::vector<std::vector<int> > break_lists;
std::vector<std::string> while_start_labels;

%}

%union{
    Node* node;
    Expression* expression;
	Statement* statement;
    Structure* structure;
    Identifier* identifier;
    ExpressionList* expression_list;
    StructMemory* struct_memory;
    StructMemList* struct_memory_list;
    Formal* formal;
    FormalStruct* formal_struct;
    FormalsList* formals_list;
	Binop* binop;
	Num* num;
	Relop* relop;
	M* m;
	N* n;
}

%nonassoc <node> STRUCT
%nonassoc <node> BOOL
%nonassoc <node> B
%nonassoc <node> BYTE
%nonassoc <node> INT
%nonassoc <identifier> STRING
%nonassoc <num> NUM
%nonassoc <identifier> ID
%nonassoc <node> VOID
%nonassoc <node> COMMA
%nonassoc <node> SC
%nonassoc <node> CONTINUE
%nonassoc <node> BREAK
%nonassoc <node> WHILE
%nonassoc <node> ELSE
%nonassoc <node> IF
%nonassoc <node> RETURN
%nonassoc <node> FALSE
%nonassoc <node> TRUE
%nonassoc <node> RBRACE
%nonassoc <node> LBRACE
%right <node> ASSIGN
%left <node> OR
%left <node> AND
%nonassoc <relop> RELOP
%left <binop> BINOP
%right <node> NOT
%left <node> PERIOD
%left <node> RPAREN
%left <node> LPAREN

%type <expression> RetType Type Exp BoolExp Call ELM
%type <statement> Statement SimpleStatement Statements ClosedStatement OpenStatement
%type <formals_list> FormalsList Formals
%type <formal_struct> FormalDecl
%type <struct_memory_list> StructMemList
%type <struct_memory> StructMem
%type <expression_list> ExpList
%type <structure> StructType
%type <m> M WM
%type <n> N



%%

Program:            Structs Funcs {
                                    if(!isSymInTable("main", tables_stack)){
                                        output::errorMainMissing();
                                        exit(0);
                                    }
                                    SymEntry e = getSymbolEntry("main", tables_stack);
                                    if(e.type != FUNCTYPE || !e.func_type.first.empty() || e.func_type.second != NOTYPE){
                                        output::errorMainMissing();
                                        exit(0);
                                    }
                                    popScope();
                                  };

Funcs:              /*epsilon*/
                    | FuncDecl Funcs
;

FuncDecl:           RetType ID {checkID($2->ID);} LPAREN Formals RPAREN {
    addFuncScope($2->ID, $5->formals, $1->exp_type);
} LBRACE Statements RBRACE {
    popScope();
    cur_ret_type = VOIDEXP;
    emitFuncEnd($2->ID);
};

Structs:            /*epsilon*/
                    | StructsDecl Structs
;

StructsDecl:        STRUCT ID {checkID($2->ID);} LBRACE StructMemList RBRACE SC {
                                                                structs_stack.back().push_back(StructType($2->ID, $5->fields));
                                                             };

RetType:            Type {$$ = $1;}
                    | VOID {
									$$ = new Expression(VOIDEXP,-1);
						   }
;

Formals:            {$$ = new FormalsList();}
                    | FormalsList {$$ = $1;}
;

FormalsList:        FormalDecl {
                                    $$ = new FormalsList();

                                    $$->formals.push_back(*$1);

                                    delete $1;
                               }
                    | FormalDecl COMMA FormalsList {
                                                        $$ = $3;

                                                        if($3->isParamNameTaken($1->ID)){
                                                            output::errorDef(yylineno, $1->ID);
                                                            exit(0);
                                                        }

                                                        $$->formals.insert($$->formals.begin(), *$1);

                                                        delete $1;
                                                   }
;

FormalDecl:         Type ID {
                                if(isSymInTable($2->ID, tables_stack) || isStructTypeInTable(structs_stack, $2->ID)){
                                    output::errorDef(yylineno, $2->ID);
                                    exit(0);
                                }
                                $$ = new FormalStruct($2->ID, $1->exp_type);

                                delete $1;
                                delete $2;
							}

                    | StructType ID {
                                        if(isSymInTable($2->ID, tables_stack) || isStructTypeInTable(structs_stack, $2->ID)){
                                            output::errorDef(yylineno, $2->ID);
                                            exit(0);
                                        }
                                        $$ = new FormalStruct($2->ID, $1->struct_type);
                                        delete $1;
                                        delete $2;
                                    }
;

StructMemList:      StructMem {
                                $$ = new StructMemList();
                                $$->fields.push_back($1->field);
                                delete $1;
                              }
                    | StructMem StructMemList {
                                                $$ = $2;
                                                if($$->isFieldNameTaken($1->field.first)){
                                                    output::errorDef($2->fieldLocation($1->field.first)+$1->line, $1->field.first);
                                                    exit(0);
                                                }
                                                $$->fields.insert($$->fields.begin(), $1->field);
                                                delete $1;
                                              }
;

StructMem:          Type ID SC {
                                    $$ = new StructMemory($2->ID, expToVar($1->exp_type), yylineno);
                                    delete $1;
                                    delete $2;
                               };

Statements:         Statement {$$ = $1;}
                    | Statements Statement {
                        $$ = $2;
                        $$->nextlist = CodeBuffer::merge($1->nextlist ,$2->nextlist);
                        $$->breaklist = CodeBuffer::merge($1->breaklist ,$2->breaklist);
                    }
;

Statement:          OpenStatement
                    | ClosedStatement
;

OpenStatement:      IF M1 LPAREN BoolExp RPAREN M Statement M2 
								{
									$$=new Statement();
									CodeBuffer::instance().bpatch($4->truelist,$6->quad);
									$$->nextlist=CodeBuffer::merge($4->falselist,$7->nextlist);
									CodeBuffer::instance().bpatch($$->nextlist, CodeBuffer::instance().genLabel());
									$$->breaklist = $7->breaklist;
								}
                    | IF M1 LPAREN BoolExp RPAREN M ClosedStatement M2 N ELSE M1 M OpenStatement M2
								{
									$$=new Statement();
									CodeBuffer::instance().bpatch($4->truelist,$6->quad);
									CodeBuffer::instance().bpatch($4->falselist,$12->quad);
									$$->nextlist = CodeBuffer::merge(CodeBuffer::merge($7->nextlist, 
											$9->nextlist),$13->nextlist);
									CodeBuffer::instance().bpatch($$->nextlist, CodeBuffer::instance().genLabel());
									$$->breaklist = CodeBuffer::merge($7->breaklist,$13->breaklist);
								}
                    | WHILE M1 WM LPAREN BoolExp RPAREN M3 M OpenStatement M4 M2
								{
									$$=new Statement();
									//CodeBuffer::instance().bpatch($9->nextlist,$3->quad);
									CodeBuffer::instance().bpatch($5->truelist,$8->quad);
									emit("j "+$3->quad);
									std::string label = CodeBuffer::instance().genLabel();
									CodeBuffer::instance().bpatch($5->falselist, label);
									CodeBuffer::instance().bpatch(break_lists.back(), label);
									break_lists.pop_back();
								}
;

ClosedStatement:    SimpleStatement
                    | IF M1 LPAREN BoolExp RPAREN M ClosedStatement M2 N ELSE M1 M ClosedStatement M2
								{
									$$=new Statement();
									CodeBuffer::instance().bpatch($4->truelist,$6->quad);
									CodeBuffer::instance().bpatch($4->falselist,$12->quad);
									$$->nextlist = CodeBuffer::merge(CodeBuffer::merge($7->nextlist,$9->nextlist),$13->nextlist);
									CodeBuffer::instance().bpatch($$->nextlist, CodeBuffer::instance().genLabel());
									$$->breaklist = CodeBuffer::merge($7->breaklist,$13->nextlist);
								}
                    | WHILE M1 WM LPAREN BoolExp RPAREN M3 M ClosedStatement M4 M2
								{
                                    $$=new Statement();
                                    //CodeBuffer::instance().bpatch($9->nextlist,$3->quad);
                                    CodeBuffer::instance().bpatch($5->truelist,$8->quad);
                                    emit("j "+$3->quad);
                                    std::string label = CodeBuffer::instance().genLabel();
                                    CodeBuffer::instance().bpatch($5->falselist, label);
                                    CodeBuffer::instance().bpatch(break_lists.back(), label);
                                    break_lists.pop_back();
								}
;

SimpleStatement:    LBRACE {addEmptyScope();} Statements {popScope();} RBRACE
								{
									$$ = $3;
								}
                    | Type ID SC {
                                    std::string ID = std::string($2->ID);

                                    checkID($2->ID);
                                    tables_stack.back().addEntry($2->ID, expToVar($1->exp_type));
                                    delete $1;
                                    delete $2;

                                    int offset = tables_stack.back().lastOffset();
                                    saveDefaultVal(offset, reg_handler);

                                    updateSPBeforeCall(tables_stack.back());

                                    $$ = new Statement();
                                 }
                    | StructType ID SC {
                                        std::string type = std::string($1->struct_type);

                                        checkID($2->ID);
                                        tables_stack.back().addEntry($2->ID, $1->struct_type);
                                        delete $1;
                                        delete $2;

                                        int offset = tables_stack.back().lastOffset();
                                        for(int i=0; i<getStructTypeEntry(structs_stack, type).fields.size(); ++i){
                                            saveDefaultVal(offset + i, reg_handler);
                                        }

                                        updateSPBeforeCall(tables_stack.back());

                                        $$ = new Statement();
                                       }
                    | STRUCT ID {checkID($2->ID);} LBRACE StructMemList RBRACE SC {
                                                                                    structs_stack.back().push_back(StructType($2->ID, $5->fields));
                                                                                    delete $2;
                                                                                    delete $5;

                                                                                    $$ = new Statement();
                                                                                  }
                    | Type ID ASSIGN Exp SC {
                                                checkID($2->ID);
                                                if(!isLegalExpType($4, $1)){
                                                    output::errorMismatch(yylineno);
                                                    exit(0);
                                                }

                                                tables_stack.back().addEntry($2->ID, expToVar($1->exp_type));

                                                if($4->exp_type == BOOLEXP){
                                                    $4->used_register = reg_handler.getAvailableRegister();
                                                    emitSaveBoolRes($4, $4->used_register);
                                                }

                                                emitSaveVar($4->used_register, $2->ID, tables_stack);
                                                reg_handler.freeRegister($4->used_register);

                                                updateSPBeforeCall(tables_stack.back());

                                                $$ = new Statement();
                                            }
                    | StructType ID ASSIGN Exp SC {
                                                    checkID($2->ID);
                                                    if(!isLegalExpType($4, $1)){
                                                        output::errorMismatch(yylineno);
                                                        exit(0);
                                                    }
                                                    tables_stack.back().addEntry($2->ID, $1->struct_type);

                                                    emitStructsEq($2->ID, $4->used_register, tables_stack, getStructTypeEntry(structs_stack, $1->struct_type), reg_handler);
                                                    reg_handler.freeRegister($4->used_register);

                                                    $$ = new Statement();

                                                    updateSPBeforeCall(tables_stack.back());

                                                    delete $1;
                                                    delete $2;
                                                    delete $4;
                                                  }
                    | ID ASSIGN Exp SC {
                                            SymEntry e = getSymbolEntry($1->ID, tables_stack);
                                            if(!isSymInTable($1->ID, tables_stack) || !e.isVariable()){
                                                output::errorUndef(yylineno, $1->ID);
                                                exit(0);
                                            }
                                            if(e.type == STRUCTTYPE){
                                                if(!isLegalExpType($3, e.struct_type)){
                                                    output::errorMismatch(yylineno);
                                                    exit(0);
                                                }
                                                emitStructsEq($1->ID, $3->used_register, tables_stack, getStructTypeEntry(structs_stack, e.struct_type), reg_handler);
                                            } else {
                                                if(!isLegalExpType($3, varToExp(e.type))){
                                                    output::errorMismatch(yylineno);
                                                    exit(0);
                                                }

                                                if($3->exp_type == BOOLEXP){
                                                    $3->used_register = reg_handler.getAvailableRegister();
                                                    emitSaveBoolRes($3, $3->used_register);
                                                }

                                                emitSaveVar($3->used_register, $1->ID, tables_stack);
                                            }

                                            reg_handler.freeRegister($3->used_register);

                                            $$ = new Statement();

                                            delete $1;
                                            delete $3;
                                       }
                    | ID PERIOD ID ASSIGN Exp SC {
                                                    SymEntry e = getSymbolEntry($1->ID, tables_stack);
                                                    if(!isSymInTable($1->ID, tables_stack) || !e.isVariable()){
                                                        output::errorUndef(yylineno, $1->ID);
                                                        exit(0);
                                                    }
                                                    if(e.type != STRUCTTYPE){
                                                        output::errorMismatch(yylineno);
                                                        exit(0);
                                                    }
                                                    if(!isStructTypeInTable(structs_stack, e.struct_type)){
                                                        output::errorUndefStruct(yylineno, e.struct_type);
                                                        exit(0);
                                                    }
                                                    StructType t = getStructTypeEntry(structs_stack, e.struct_type);
                                                    VarType field_type = t.getFieldType($3->ID);
                                                    if(field_type == NOTYPE){
                                                        output::errorUndefStructMember(yylineno, $1->ID);
                                                        exit(0);
                                                    }
                                                    if(!isLegalExpType($5, varToExp(field_type))){
                                                        output::errorMismatch(yylineno);
                                                        exit(0);
                                                    }

                                                    if($5->exp_type == BOOLEXP){
                                                        $5->used_register = reg_handler.getAvailableRegister();
                                                        emitSaveBoolRes($5, $5->used_register);
                                                    }

                                                    emitSaveStructField($5->used_register, $1->ID, $3->ID, tables_stack, getStructTypeEntry(structs_stack, e.struct_type));
                                                    reg_handler.freeRegister($5->used_register);

                                                    $$ = new Statement();

                                                    delete $1;
                                                    delete $3;
                                                    delete $5;
                                                 }
                    | Call SC {
                        if($1->used_register != -1){
                            reg_handler.freeRegister($1->used_register);
                        }

                        $$ = new Statement();
                    }
                    | RETURN SC {
                                    if(cur_ret_type != VOIDEXP){
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }

                                    emitReturn();
                                    $$ = new Statement();
                                }
                    | RETURN Exp SC {
                                        if(!isLegalExpType($2, cur_ret_type)){
                                            output::errorMismatch(yylineno);
                                            exit(0);
                                        }

                                        if($2->exp_type == BOOLEXP){
                                            $2->used_register = reg_handler.getAvailableRegister();
                                            emitSaveBoolRes($2, $2->used_register);
                                        }

                                        emitReturn($2->used_register);
                                        reg_handler.freeRegister($2->used_register);
                                        $$ = new Statement();

                                        delete $2;
                                    }
                    | BREAK SC {
                                if(num_of_while_scopes == 0){
                                    output::errorUnexpectedBreak(yylineno);
                                    exit(0);
                                }
                                $$ = new Statement();

								$$->breaklist=CodeBuffer::makelist(emit("j "));

								if(!break_lists.back().empty()){
								    $$->breaklist = CodeBuffer::merge(break_lists.back(), $$->breaklist);
								}
                                break_lists.pop_back();
                                break_lists.push_back($$->breaklist);
                               }
                    | CONTINUE SC {
                                    if(num_of_while_scopes == 0){
                                        output::errorUnexpectedContinue(yylineno);
                                        exit(0);
                                    }
                                    $$ = new Statement();

									emit("j " + while_start_labels.back());
                                  }
;

Call:               ID LPAREN {emitSetupFuncCall($1->ID, tables_stack.back(), reg_handler);} ExpList RPAREN {
                                                    SymEntry func_e = getSymbolEntry($1->ID, tables_stack);
                                                    if(!isSymInTable($1->ID, tables_stack) || func_e.type != FUNCTYPE){
                                                        output::errorUndefFunc(yylineno, $1->ID);
                                                        exit(0);
                                                    }
                                                    if($4->expressions.size() != func_e.func_type.first.size()){
                                                        std::vector<std::string> arg_t = funcArgTypes(func_e.func_type);
                                                        output::errorPrototypeMismatch(yylineno, $1->ID, arg_t);
                                                        exit(0);
                                                    }

                                                    std::vector<Structure>::iterator it_exp =  $4->expressions.begin();
                                                    std::vector<FuncParam>::iterator it_arg =  func_e.func_type.first.begin();
                                                    for(; it_exp != $4->expressions.end() && it_arg != func_e.func_type.first.end(); ++it_exp){
                                                        bool is_legal = true;
                                                        if((*it_arg).type != STRUCTTYPE || (*it_exp).exp_type != STRUCTEXP){
                                                            is_legal = isLegalExpType((*it_exp).exp_type, varToExp((*it_arg).type));
                                                        } else {
                                                            is_legal = isLegalExpType((*it_exp).struct_type, (*it_arg).struct_type);
                                                        }

                                                        if(!is_legal){
                                                            std::vector<std::string> arg_t = funcArgTypes(func_e.func_type);
                                                            output::errorPrototypeMismatch(yylineno, $1->ID, arg_t);
                                                            exit(0);
                                                        }
                                                        ++it_arg;
                                                    }

                                                    //call func
                                                    emitFuncCall($1->ID, tables_stack, structs_stack, reg_handler);

                                                    int reg=reg_handler.getAvailableRegister();
                                                    $$ = new Expression((varToExp(func_e.func_type.second)),reg);

                                                    //save return value
                                                    emit("move " + regName(reg) +", $v0");

                                                    delete $1;
                                                    delete $4;
                                             }
                    | ID LPAREN RPAREN {
                                            SymEntry func_e = getSymbolEntry($1->ID, tables_stack);
                                            if(!isSymInTable($1->ID, tables_stack) || func_e.type != FUNCTYPE){
                                                output::errorUndefFunc(yylineno, $1->ID);
                                                exit(0);
                                            }
                                            if(!func_e.func_type.first.empty()){
                                                std::vector<std::string> arg_t = funcArgTypes(func_e.func_type);
                                                output::errorPrototypeMismatch(yylineno, $1->ID, arg_t);
                                                exit(0);
                                            }

                                            //setup func call
                                            emitSetupFuncCall($1->ID, tables_stack.back(), reg_handler);

                                            //call func
                                            emitFuncCall($1->ID, tables_stack, structs_stack, reg_handler);

                                            int reg=reg_handler.getAvailableRegister();
                                            $$ = new Expression((varToExp(func_e.func_type.second)),reg);

                                            //save return value
                                            emit("move " + regName(reg) +", $v0");
                                            delete $1;
                                       }
;

ExpList:            Exp {
                            $$ = new ExpressionList();
                            $$->expressions.push_back(expressionToList($1));

                            if($1->exp_type == BOOLEXP){
                                $1->used_register = reg_handler.getAvailableRegister();
                                emitSaveBoolRes($1, $1->used_register);
                            }

                            emitComment("pushing func arguments into stack");
                            //push the expression value
                            pushExp($1, reg_handler, structs_stack);
                            //free the register
                            reg_handler.freeRegister($1->used_register);

                            delete $1;
                        }
                    | ELM ExpList {
                                            $$ = $2;
                                            $$->expressions.insert($$->expressions.begin(), expressionToList($1));

                                            //push the expression value
                                            pushExp($1, reg_handler, structs_stack);
                                            //free the register
                                            reg_handler.freeRegister($1->used_register);

                                            delete $1;
                                        }
;

Type:               INT {
							$$ = new Expression(INTEXP,-1);
						}
                    | BYTE 
						{
							$$ = new Expression(BYTEEXP,-1);
						}
                    | BOOL 
						{
							$$ = new Expression(BOOLEXP,-1);
						}
;

StructType:         STRUCT ID {
                        if(!isStructTypeInTable(structs_stack, $2->ID)){
                            output::errorUndefStruct(yylineno, $2->ID);
                            exit(0);
                        }
                        $$ = new Structure($2->ID);
                        delete $2;
                    };

Exp:                LPAREN Exp RPAREN {
										$$ = $2;
									  }
                    | Exp BINOP Exp {
                                        if(!isNumExp($1) || !isNumExp($3)){
                                            output::errorMismatch(yylineno);
                                            exit(0);
                                        }
                                        $$ = new Expression((operatorType($1, $3)),$1->used_register);

                                        //if is div, check divide by zero error
                                        if($2->BINOP == "/"){
                                            emitDivByZeroCheck($3->used_register, div_by_zero_label);
                                        }

                                        //emit code computing the expression
                                        emit(operatorString($1, $3, $2->BINOP, reg_handler));
                                        //if the result should be a byte, mask it with 255
                                        if(operatorType($1, $3) == BYTEEXP){
                                             emit(truncByte($$));
                                        }
                                    }
                    | ID {
                            SymEntry e = getSymbolEntry($1->ID, tables_stack);
                            if(!isSymInTable($1->ID, tables_stack) || !e.isVariable()){
                                output::errorUndef(yylineno, $1->ID);
                                exit(0);
                            }
                            if(e.type == STRUCTTYPE){
                                $$ = new Structure(e.struct_type);
                            } else {
                                $$ = new Expression((varToExp(e.type)),-1);
                            }

							int reg=reg_handler.getAvailableRegister();
                            //load value into register
                            emitLoadVar(reg, $1->ID, tables_stack);

							//check if this is a boolean expression
							if ($$->exp_type==BOOLEXP){
								$$->falselist=CodeBuffer::makelist(emit("beq " + regName(reg) + ", 0, "));
								$$->truelist=CodeBuffer::makelist(emit("j "));
								reg_handler.freeRegister(reg);
							}
							//if it isn't a boolean expression then just save the value in a register;
							else{
								$$->used_register = reg;
							}
                         }
                    | ID PERIOD ID {
                                        SymEntry e = getSymbolEntry($1->ID, tables_stack);
                                        if(!isSymInTable($1->ID, tables_stack) || !e.isVariable()){
                                            output::errorUndef(yylineno, $1->ID);
                                            exit(0);
                                        }
                                        if(e.type != STRUCTTYPE){
                                            output::errorMismatch(yylineno);
                                            exit(0);
                                        }
                                        if(!isStructTypeInTable(structs_stack, e.struct_type)){
                                            output::errorUndefStruct(yylineno, e.struct_type);
                                            exit(0);
                                        }
                                        StructType t = getStructTypeEntry(structs_stack, e.struct_type);
                                        VarType field_type = t.getFieldType($3->ID);
                                        if(field_type == NOTYPE){
                                            output::errorUndefStructMember(yylineno, $1->ID);
                                            exit(0);
                                        }
										int reg = reg_handler.getAvailableRegister();
										//load value into register
                                        emitLoadStructField(reg, $1->ID, $3->ID, tables_stack, t);

                                        //check if this is a boolean expression
                                        if ($$->exp_type==BOOLEXP){
                                            $$->falselist=CodeBuffer::makelist(emit("beq " + regName(reg) + ", 0, "));
                                            $$->truelist=CodeBuffer::makelist(emit("j "));
                                            reg_handler.freeRegister(reg);
                                            reg = -1;
                                        }
                                        //if it isn't a boolean expression then just save the value in a register;

                                        $$ = new Expression((varToExp(field_type)),reg);
                                        delete $1;
                                        delete $3;
                                   }
                    | Call {$$ = $1;}
                    | NUM {
                            $$ = new Expression(INTEXP,reg_handler.getAvailableRegister());
							emit("li " + regName($$->used_register) + ", " + $1->value);
                          }
                    | NUM B {
								string val_str = $1->value;
                                if(strtol(val_str.c_str(), NULL, 10) > 255){
                                    output::errorByteTooLarge(yylineno, val_str);
                                    exit(0);
                                }

								$$ = new Expression(BYTEEXP,reg_handler.getAvailableRegister());
								emit("li "+regName($$->used_register)+", "+$1->value);

                                delete $1;
                            }
                    | STRING{
								$$ = new Expression(STRINGEXP,reg_handler.getAvailableRegister());
								std::string label = strData($1->ID);
								emit("la " + regName($$->used_register) + ", " + label);
							}
                    | TRUE  {
								$$ = new Expression(BOOLEXP,-1);
								$$->truelist=CodeBuffer::makelist(emit("j "));
							}
                    | FALSE {
								$$ = new Expression(BOOLEXP,-1);
								$$->falselist=CodeBuffer::makelist(emit("j "));
							}
                    | NOT Exp {
                                if($2->exp_type != BOOLEXP){
                                    output::errorMismatch(yylineno);
                                    exit(0);
                                }
                                $$ = new Expression(BOOLEXP,-1);
								$$->truelist=$2->falselist;
								$$->falselist=$2->truelist;

                                delete $2;
                              }
                    | Exp AND M Exp {
                                    if($1->exp_type != BOOLEXP || $4->exp_type != BOOLEXP){
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }
                                    $$ = new Expression(BOOLEXP,-1);
									CodeBuffer::instance().bpatch($1->truelist,$3->quad);
									$$->truelist=$4->truelist;
									$$->falselist=CodeBuffer::merge($1->falselist,$4->falselist);

                                  }
                    | Exp OR M Exp {
                                    if($1->exp_type != BOOLEXP || $4->exp_type != BOOLEXP){
                                        output::errorMismatch(yylineno);
                                        exit(0);
                                    }
                                    $$ = new Expression(BOOLEXP,-1);
									CodeBuffer::instance().bpatch($1->falselist,$3->quad);
									$$->falselist = $4->falselist;
									$$->truelist = CodeBuffer::merge($1->truelist, $4->truelist);

                                 }
                    | Exp RELOP Exp {
                                        if(!isNumExp($1) || !isNumExp($3)){
                                            output::errorMismatch(yylineno);
                                            exit(0);
                                        }
                                        $$ = new Expression(BOOLEXP,-1);

                                        //code generation
                                        $$->truelist=CodeBuffer::makelist(emit(relopString($1, $3, $2->op)));
                                        $$->falselist=CodeBuffer::makelist(emit("j "));
                                        //free registers
                                        reg_handler.freeRegister($1->used_register);
                                        reg_handler.freeRegister($3->used_register);
									 }
;

BoolExp:            Exp {
                            if(!isLegalExpType($1, BOOLEXP)){
                                output::errorMismatch(yylineno);
                                exit(0);
                            }
							$$=$1;
                        }
;

WM:                     {
                            $$ = new M();
                            $$->quad=CodeBuffer::instance().genLabel();
                            while_start_labels.push_back($$->quad);
                        }

M:					/*epsilon*/
						{
							$$ = new M();
							$$->quad=CodeBuffer::instance().genLabel();
						}

;

N:					/*epsilon*/
						{
							$$ = new N();
							$$->nextlist=CodeBuffer::makelist(emit("j "));
						}

;

M1:                 {addEmptyScope();}
;

M2:                 {popScope();}
;

M3:                  {
    M3Code();
}
;

M4:                 {
    M4Code();
}
;

ELM:        Exp COMMA {
    if($1->exp_type == BOOLEXP){
        $1->used_register = reg_handler.getAvailableRegister();
        emitSaveBoolRes($1, $1->used_register);
    }

    $$ = $1;
}

%%

int main(){
    reg_handler = regHandler();
    div_by_zero_label = emitDivByZeroHandler();

    structs_stack = std::vector <std::vector<StructType> >();
    structs_stack.push_back(std::vector<StructType>());

    tables_stack = std::vector<SymTable>();
    tables_stack.push_back(SymTable(&structs_stack));

    addPrints();
    yyparse();

    CodeBuffer::instance().printDataBuffer();
    std::cout << std::endl;
    std::cout << std::endl;
    CodeBuffer::instance().printCodeBuffer();

    return 0;
}

void yyerror(const char*){
    output::errorSyn(yylineno);
    exit(0);
}

void checkID(std::string& ID){
    if(isStructTypeInTable(structs_stack, ID) || isSymInTable(ID, tables_stack)){
        output::errorDef(yylineno, ID);
        exit(0);
    }
}

void addPrints(){
    std::vector<FuncParam> print_func_params = std::vector<FuncParam>();
    std::vector<FuncParam> printi_func_params = std::vector<FuncParam>();

    print_func_params.push_back(FuncParam(STRINGTYPE));
    printi_func_params.push_back(FuncParam(INTTYPE));

    tables_stack.back().addEntry("print", print_func_params, NOTYPE);
    //emit code for print
    emitFuncStart("print");
    emit("lw $a0,4($fp)");
    emit("li $v0,4");
    emit("syscall");
    emit("jr $ra");
    emitFuncEnd("print");

    tables_stack.back().addEntry("printi", printi_func_params, NOTYPE);
    //emit code for printi
    emitFuncStart("printi");
    emit("lw $a0,4($fp)");
    emit("li $v0,1");
    emit("syscall");
    emit("jr $ra");
    emitFuncEnd("printi");
}

void popScope(){
    std::vector<SymEntry> scope_entries = tables_stack.back().scope_entries;

    //output::endScope();

    for(std::vector<SymEntry>::iterator it = scope_entries.begin(); it != scope_entries.end(); ++it){
        std::string type;

        if((*it).type == FUNCTYPE){
            type = funcToString((*it).func_type);
        } else{
            type = typeToString((*it).type) + (((*it).type == STRUCTTYPE) ? (" " + (*it).struct_type) : "");
        }

        //output::printID((*it).ID, (*it).offset, type);
    }

    std::vector<StructType> scope_structs = structs_stack.back();

    for(std::vector<StructType>::iterator it = scope_structs.begin(); it != scope_structs.end(); ++it){
        vector<std::string> memTypes = vector<std::string>();
        vector<std::string> memNames = vector<std::string>();

        for(StructFieldsType::const_iterator field_it = (*it).fields.begin(); field_it != (*it).fields.end(); ++field_it){
            memTypes.push_back(typeToString((*field_it).second));
            memNames.push_back((*field_it).first);
        }

        //output::printStructType((*it).type_name, memTypes, memNames);
    }

    tables_stack.pop_back();
    structs_stack.pop_back();
}

std::string funcToString(FunctionType &func_type){
    std::string t = typeToString(func_type.second);
    std::vector<std::string> func_args = funcArgTypes(func_type);
    return output::makeFunctionType(t, func_args);
}

std::vector<std::string> funcArgTypes(FunctionType &func_type){
    std::vector<std::string> argTypes = vector<std::string>();

    for(std::vector<FuncParam>::iterator it = func_type.first.begin(); it != func_type.first.end(); ++it){
        argTypes.push_back(typeToString((*it).type) + (((*it).type == STRUCTTYPE) ? (" " + (*it).struct_type) : ""));
    }

    return argTypes;
}

std::string typeToString(VarType type){
    switch(type){
        case INTTYPE:
            return "INT";
        case BYTETYPE:
            return "BYTE";
        case BOOLTYPE:
            return "BOOL";
        case STRUCTTYPE:
            return "struct";
        case STRINGTYPE:
            return "STRING";
        default:
            return "VOID";
    }
}

void addFuncScope(const std::string &ID, const std::vector<FormalStruct> &formals, ExpType ret_type){
    cur_ret_type = ret_type;

    std::vector<FuncParam> func_params = std::vector<FuncParam>();

    for(std::vector<FormalStruct>::const_iterator it = formals.begin(); it!=formals.end(); ++it){
        if((*it).type == STRUCTEXP){
            func_params.push_back(FuncParam((*it).struct_type));
        } else {
            func_params.push_back(FuncParam(expToVar((*it).type)));
        }
    }

    tables_stack.back().addEntry(ID, func_params, expToVar(ret_type));

    addEmptyScope();

    int offset = 0;
    for(std::vector<FormalStruct>::const_iterator it = formals.begin(); it!=formals.end(); ++it){
        SymEntry* e;

        if((*it).type == STRUCTEXP){
            offset -= tables_stack.back().structTypeOffset((*it).struct_type);
            e = new SymEntry((*it).ID, (*it).struct_type, offset);
        } else {
            e = new SymEntry((*it).ID, expToVar((*it).type), --offset);
        }

        tables_stack.back().addEntry(*e);
        delete e;
    }

    emitFuncStart(ID);
    //add empty place for local variables
}

void addEmptyScope(){
    SymTable t = SymTable(&structs_stack, tables_stack.back().nextOffset());
    tables_stack.push_back(t);
    structs_stack.push_back(std::vector<StructType>());
}

VarType expToVar(ExpType e){
    switch(e){
        case INTEXP:
            return INTTYPE;
        case BYTEEXP:
            return BYTETYPE;
        case BOOLEXP:
            return BOOLTYPE;
        case STRUCTEXP:
            return STRUCTTYPE;
        case FUNCEXP:
            return FUNCTYPE;
        case STRINGEXP:
            return STRINGTYPE;
        default:
            //note that no entry in the symbol table can be string or void!
            return NOTYPE;
    }
}

ExpType varToExp(VarType t){
    switch(t){
        case INTTYPE:
            return INTEXP;
        case BYTETYPE:
            return BYTEEXP;
        case BOOLTYPE:
            return BOOLEXP;
        case STRUCTTYPE:
            return STRUCTEXP;
        case FUNCTYPE:
            return FUNCEXP;
        case STRINGTYPE:
            return STRINGEXP;
        default:
            //note that no entry in the symbol table can be string or void!
            return VOIDEXP;
    }
}

void M3Code(){
    ++num_of_while_scopes;
    break_lists.push_back(std::vector<int>());
}

void M4Code(){
    --num_of_while_scopes;
    while_start_labels.pop_back();
}